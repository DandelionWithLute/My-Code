下面来看看示例 2-16 中 Python 为表达式 s[a] += b 生成的字节码，可
能这个现象背后的原因会变得清晰起来。
示例 2-16 s[a] = b 背后的字节码
>>> dis.dis('s[a] += b')
1 0 LOAD_NAME 0(s)
3 LOAD_NAME 1(a)
6 DUP_TOP_TWO
7 BINARY_SUBSCR ➊
8 LOAD_NAME 2(b)
11 INPLACE_ADD ➋
12 ROT_THREE
13 STORE_SUBSCR ➌
14 LOAD_CONST 0(None)
17 RETURN_VALUE
➊ 将 s[a] 的值存入 TOS（Top Of Stack，栈的顶端）。
➋ 计算 TOS += b。这一步能够完成，是因为 TOS 指向的是一个可变对
象（也就是示例 2-15 里的列表）。
➌ s[a] = TOS 赋值。这一步失败，是因为 s 是不可变的元组（示例 2-
15 中的元组 t）。
这其实是个非常罕见的边界情况，在 15 年的 Python 生涯中，我还没见
过谁在这个地方吃过亏。
至此我得到了 3 个教训。
不要把可变对象放在元组里面。
增量赋值不是一个原子操作。我们刚才也看到了，它虽然抛出了异
常，但还是完成了操作。
查看 Python 的字节码并不难，而且它对我们了解代码背后的运行机
制很有帮助。
在见证了 + 和 * 的微妙之处后，我们把话题转移到序列类型的另一个重
要部分上：排序。